---
layout: post
title: Java Garbage Collection Distilled 翻译
tags:
  - java
---
[Java Garbage Collection Distilled](http://www.infoq.com/articles/Java_Garbage_Collection_Distilled){:target="_blank"}

Serial, Parallel, Concurrent, CMS, G1, Young Gen, New Gen, Old Gen, Perm Gen, Eden, Tenured, Survivor Spaces, Safepoints, 还有数百个 JVM 的启动参数。当你试着优化 GC 来追求你的 Java 应用的高吞吐量和低延迟，你是否对这些参数感到困惑？如果是，也别担心，你不是一个人。GC 的文档看起来像是飞机的使用手册。每个把手和刻度盘都有详细的解释，但是没有告诉你如何飞起来的指南。这篇文章将尝试去解释如何在特定的压力下选择和优化 GC。

本文将只讨论 Oracle Hotspot JVM 和 Open JDK 的垃圾回收机制，因为它们是最常用的。文章末尾将会讨论其他商用的 JVM 作为其他选择。

<!--more-->

### 吞吐量、延迟、内存的取舍

古语有云，“有得必有失”。在优化 GC 时，我们从三个主要方面来设定垃圾回收的性能指标。

  1. 吞吐率： 在一定时间内应用可以完成的工作量。用 -XX:GCTimeRatio=99 来设定目标吞吐率；99为默认值，也就是说 GC 使用1%的时间。

  1. 延迟：GC 对系统响应时间的影响。用 -XX: MaxGCPauseMillis=<n>来设定目标延迟。

  1. 内存：系统用来存储状态使用的内存，JVM管理内存的时候经常会复制和移动内存中的数据。应用保存的活动对象的集合被称为活动集合（Live Set）。参数 -Xmx<n> 可用来设置应用的内存堆的最大空间。

注意：Hotspot经常不会达到这些指标（会有比较大的偏差），并且会没有任何警告而继续运行。

目标延迟是一个统计分布（？）。有时为了缩小或减少最坏情况下的延迟而增加了平均延迟，这是可以接受的。对于“实时”的概念，我们不应该认为是达到最小的延迟，而是不管吞吐率的大小，都有一个可以预期的确定的延迟。

对于某些应用，吞吐率是最重要的指标。举个栗子，一个长时间运行的批处理任务；只要所有的任务能够更快的完成，有时因为 GC 而造成几秒钟的暂停无关紧要。

对于其他类型的应用，从有用户交互的应用到金融交易系统，如果系统有几秒钟甚至几毫秒无法及时响应，都有可能造成灾难。在金融交易系统中，经常为了稳定的延迟而牺牲一些吞吐率。也有些应用需要在内存有限的设备上运行，这时就需要同时牺牲延迟和吞吐率。


  1. 在多数情况下，增大内存可以减少 GC 的平均开销。

  1. 最坏情况下的 GC 开销（通常是 GC 产生的暂停造成的），可以通过减少堆
    内存来减少。

  1. 暂停的频率，可以通过控制内存堆和回收代的大小，和控制应用分配对象的
    速率来控制。

  1. 暂停的频率，可以通过并行执行 GC 来减少，这有时会减少吞吐率。

### 对象生存周期

垃圾回收算法的优化经常根据这种假设：大多数对象的生存周期都很短，而相对很少部分对象会活很久。在多数的应用中，生存周期很长的对象占了应用分配的所有对象的很小的一部分。在垃圾回收理论中，这种情况陪称为 infant mortality 或者 weak generational hypothesis。比如循环操作的iterator的生存周期大多数很短，而静态字符串则一直存在。

实验表明，分代垃圾回收器比不分代的垃圾回收器，在吞吐率方面要好一个数量级，因此在服务器端的 JVM 中被广泛使用。通过对对象进行分代，我们知道一片新分配的内存中，只有很少的活动对象，因此可以将这些活动对象复制到另一个存放老对象的区域中，这个效率会很高。Hotspot 的垃圾回收器用存活了多少轮 GC 来表明对象的年龄。

注意：如果你的应用不停的产生存活时间很长的对象，那么垃圾回收将会用掉很多时间，而且你会需要一大部分时间来优化垃圾回收。这是因为分代过滤的低效和更多的对老代的回收造成了 GC 的低效。老代的活动对象更加密集，因此对老代的回收算法效率更低。分代的垃圾回收器分成两个不同的回收周期：Minor collection，收集生命周期短的对象，和频率较低的 Major collection，收集老代的区域。

### Stop-The-World 事件

Stop-the-world 事件造成了应用在 GC 的时候暂停响应。因为实际工程的原因，垃圾回收器管理内存的时候，必须定期地停止应用的运行。根据算法的不同，不同回收器会在不同的时间停止应用的运行。要将应用完全停止，需要暂停所有线程。垃圾回收器通过给线程发送信号，告诉线程在“安全点”停下来，安全点是在程序执行过程中，所有 GC roots 都已知了，并且所有内存堆上的对象都在稳定的状态。根据正在做的事情，一个线程可能需要一些时间来达到安全点。对安全点的检查通常在方法返回和循环的边界上执行，但是可以在某些地方进行优化，使安全点检查更少的发生。例如，如果一个线程正在复制一个大数组，克隆一个大对象，或者进行一个有限的循环计数，可能需要数毫秒才能达到安全点。达到安全点的延迟是低延迟应用的一个重要考量。这个时间可以通过打开参数 -XX:+PrintGCApplicationStoppedTime （和其他一些 GC 参数）来显示。

注意：对于有很多运行线程的应用来说，当线程从 stop-the-world 恢复运行时，系统会受很大的调度压力。因此对stop-the-world依赖更少的算法有更好的性能优化的潜力。

### Hotspot 中堆的结构

要理解不同的回收器的工作方式，最好要了解 Java 的堆的结构，并且知道堆是如何支持分代回收的。

Eden 是大多数对象最初分配空间的区域。Survivor 空间是存放存活了一次 Eden 空间 GC 的对象的临时区域。Survivor 区域的使用将在讨论 minor collection 的时候描述。Eden 和 survivor 空间被合称为“新生代”（young or new generation）。

存活时间足够长的对象最终会被放入老年代（tenured）空间。

永久代（perm generation）是 JVM 存储那些它知道基本不会被释放的对象，如类和静态字符串。不幸的是，很多应用使用的运行过程中进行类加载，使这个假设（类是不会被释放的）不成立了。在 Java 7 中，interned 字符串从永久代挪到了老年代，从 Java 8 开始，永久代将被去掉，本文将不讨论永久代。多数其他的商业垃圾回收器不使用单独的永久代空间，所有长期存活的对象都放入老年代。

注意：虚拟空间允许回收器调整各个区域的大小，以达到目标的吞吐率和延迟。回收器会保存每个回收阶段的统计数据并相应调整各区域的大小以达到目标。

### 对象的分配

为避免竞争，每个线程有一个 TLAB (Thread Local Allocation Buffer)用来分配对象。TLAB 使多线程分配对象不会因为竞争而出现瓶颈。通过 TLAB 分配对象的开销是很低的，它仅仅将指针往后移动这个对象的大小，这在很多平台上只需要10来个指令。Java 的堆内存的分配甚至比 C 的 malloc 开销还小。

![Hotspot Heap Organization]({{ site.url }}/images/posts/2014-10-11/heap-organization.jpg)

注意：虽然单个对象的内存分配开销很小，minor collection 被触发的频率与对象的分配频率成线性关系。

当一个线程用完了 TLAB，它就向 Eden 空间申请一块新的。当 Eden 空间被填满就会触发一个 minor colleciton。

关于参数 -XX:PretenureSizeThreshold=n。一些对象（比如一个大数组）可能太大而无法放入新生代，因此必须被放入老年代。如果这个参数设置为小于 TLAB 的大小，那么如果对象可以被放入 TLAB，则不会被放入老年代。新的 G1 对于大对象有不同的分配方式，后面将会单独讨论。

### Minor Collections

当 Eden 满了之后，会触发一次 minor collection。所有新生代中活动的对象将被复制到 survivor 空间或是老年代。复制到老年代被成为 promotion 或 tenuring。两种情况下会发生 promotion， 对象已经足够老了（-XX:MaxTenuringThreshold），或者 survivor 空间溢出了。

活动对象是那些应用可以达到的对象；其他的所有对象都是不能达到的，因此被认为是“死的”。在 minor collection 中，复制对象的过程首先从 GC Root 开始，不断地复制可以到达的对象到 survivor 区域。GC Roots 通常包括应用和 JVM 的静态变量引用，和线程的运行栈上的引用，这些是指向应用的可到达对象。

在分代回收中，新生代的可到达的 GC Roots 还包括从老年代指向新生代的引用。这些引用也必须被处理以保证新生代中的所有可到达对象都存活下来。回收器使用 card table 来查找这些代之间的引用。Hotspot 的 card table 是一个字节数组，每个字节用来记录对应的老年代中的512个字节是否有指向新生代的引用。当应用被保存到堆中时，store barrier 代码会在 card table 中记录一下可能的老年代新生代间的引用。在回收的时候，card table 会被扫描，检查是否有代间的引用，并作为新生代的额外的 GC Roots。因此 minor collection 的开销中用一个固定的部分，直接与老年代的大小线性相关。

Hotspot 的新生代有两个 survivor 空间，轮流作为 to-space 和 from-space。在 minor collection 开始的时候，to-space 空间总是空的，作为复制对象的目标空间。前一次 minor collection 的目标 survivor 空间是 from-space 的一部分，from-space 也包括包含需要复制的对象的 Eden 空间。

Minor GC collection 的开销通常由向 survivor 和 tenured 空间复制对象的开销决定。Minor collection 中没有存活的对象可以被直接丢弃。Minor collection 的工作量与活动对象的数量而不是新生代的大小成正比。当 Eden 空间增加一倍，minor collection 的总时间几乎会减半。因此牺牲内存可以获得吞吐率。增加 Eden 的大小会造成一次回收用掉更多时间，但是如果需要 promote 的对象数量和老年代的大小是一样的，这个时间的增加相对来说很小。

注意：在 Hotspot 中，minor colleciton 是 stop-the-world 的事件。当堆变大而活动对象变多时，这变成一个大问题。我们已经需要将新生代的回收变成同步的来达到暂停时间的指标。

### Major Collections


